# -*- coding: utf-8 -*-
"""
Created on Tue Jun  6 11:44:41 2023

@author: ANKITA KANNAN IYER
"""

# -*- coding: utf-8 -*-
"""Untitled6.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1xeM5wEdpVuAdK_NIWwjZp8g3RjU4vvhp
"""

import scipy.io as spio
import os
import matplotlib.pyplot as plt
import numpy as np

####
f=3.17e6
c=3e8 
wl=c/f   

## wl=94.5718 # in m 

# Question 1
d = 0.5 * wl    # for q1a
#d = 1.0 * wl    # for q1b
#d = 1.5 * wl    # for q1c

def antennae_position(d):
  # positions of antennae in Equilateral 3 antenna array (triangle with equal sides)
  antpos=np.empty([3]).astype(complex)
  antpos[0] = 0+0j
  antpos[1] = d+0j
  antpos[2] = d*np.cos(60*np.pi/180) + d*np.sin(60*np.pi/180)*1j
  return antpos

antpos = antennae_position(d)

# Question 2
# Generate complex random data with matrix size (2000,100,3)
# Gaussian distribution
data = np.random.normal(loc=0, scale=1/np.sqrt(2), size=(2000,100,3)) + 1j*np.random.normal(loc=0, scale=1/np.sqrt(2), size=(2000,100,3))

# number of range gates , data points, receivers
noRG=np.size(data,0)
noDP=np.size(data,1)
noRx=np.size(data,2)

# perform coherent integrations
#def make_ci(t, y, ci):
def make_ci(y, ci):
    nptsn=int(np.floor(len(y)/ci))
    yn=np.empty(nptsn)+1j*np.empty(nptsn)
    #tn=np.empty(nptsn)
    for i in range(0,nptsn):
        yn[i]=np.mean(y[i*ci:i*ci+ci-1])
        #tn[i]=np.mean(t[i*ci:(i+1)*ci])
    #return tn,yn
    return yn

ci=8;

noDPn=int(np.floor(noDP/ci))
# predefine matrix for integrated raw data
datan=np.zeros([noRG,noDPn,noRx])+1j*np.zeros([noRG,noDPn,noRx])

for rx in range(noRx):
    for rg in range(noRG):
        #tn,datan[rg,:,rx]=make_ci(t,data[rg,:,rx],ci)
        datan[rg,:,rx]=make_ci(data[rg,:,rx],ci)

data=datan[:]
#t=tn[:]
noDP=np.size(data,1)

data.shape

plt.figure()
for rx in range(3):
    plt.subplot(1,3,rx+1)
    plt.plot(np.real(data[:,0,rx]),np.imag(data[:,0,rx]),'.')
    #plt.axis([-10,10,-10,10])
    plt.grid(1)
    plt.title(('I/Q RX ', str(rx)))
#

plt.figure()
for rx in range(3):
    plt.subplot(1,6,2*rx+1)
    plt.hist(np.real(data[:,0,rx]))
    plt.title(('Histogram I data of RX ', str(rx)))

    plt.subplot(1,6,2*rx+2)
    plt.hist(np.imag(data[:,0,rx]))
    plt.title(('Histogram Q data of RX ', str(rx)))
plt.show()
#

def AOA(antpos, data, wl):

  noRG=np.size(data,0)
  noDP=np.size(data,1)
  noRx=np.size(data,2)

  pairs=[[0,1],[0,2],[1,2]]

  # pairs=np.zeros((2,3))
  # pairs=np.ndarray([0,1],[0,2],[1,2])

  #pairs
  nopairs=np.size(pairs,0)

  dx=np.zeros([nopairs])
  dy=np.zeros([nopairs])
  #phases=np.zeros([noRG,noDP,nopairs])
  phases=np.zeros([noRG,nopairs])
  # phases=np.angle(data[30,:,0]*np.conjugate(data[30,:,1]))

  # pp=0
  for pp in range(nopairs):
      dx[pp]=(antpos[pairs[pp][0]]-antpos[pairs[pp][1]]).real
      dy[pp]=(antpos[pairs[pp][0]]-antpos[pairs[pp][1]]).imag
      # phases[:,pp]=np.angle(datamean[:,pairs[pp][0]]*np.conjugate(datamean[:,pairs[pp][1]]))
      phases[:,pp]=np.angle(np.nanmean(data[:,:,pairs[pp][0]]*np.conjugate(data[:,:,pairs[pp][1]]),1))

  R=2*np.pi/wl * np.array([dx, dy])
  #R=np.transpose(R)
  R=R.T


  # least squares matrix solving 
  # numpy linalg 
  # https://numpy.org/doc/stable/reference/generated/numpy.linalg.solve.html

  #B=np.matmul(np.transpose(np.mat(R)),np.mat(R))
  B=np.matmul(np.mat(R).T,np.mat(R))


  pos_data=np.zeros([noRG,2])
  phi=np.zeros([noRG,1])
  theta=np.zeros([noRG,1])

  rg=0
  for rg in range(noRG):
  #b=np.matmul(np.transpose(np.mat(R)),np.transpose(np.mat(phases[0,:])))
      b=np.matmul(np.mat(R).T,np.mat(phases[rg,:]).T)

      r=np.linalg.solve(B.T.dot(B), B.T.dot(b))
      #r=np.linalg.lstsq(B,b,rcond=None)[0]
      pos_data[rg,:]=r.T
      phi[rg]=np.arctan2(r[1],r[0])/np.pi*180
      theta[rg]=np.arcsin(np.sqrt(r[0]**2+r[1]**2))/np.pi*180

  return pos_data

# Question3
#3a
d = 0.5 * wl    # for q3a
antpos = antennae_position(d)
pos_data = AOA(antpos, data, wl)
plt.figure()
plt.plot(np.real(antpos), np.imag(antpos),'rs')
plt.xlim([-10,150])
plt.ylim([-10,150])
plt.grid(1)
plt.title('Antenna Placing for 0.5*wl antenna distance')

plt.figure()
plt.plot(pos_data[15:,0],pos_data[15:,1],'.')
plt.xlim([-1,1])
plt.ylim([-1,1])
plt.grid(1)
plt.xlabel('dcosx sin(theta)cos(phi)')
plt.ylabel('dcosy sin(theta)sin(phi)')
plt.title('AOA Coverage for 0.5*wl antenna distance')


#3b
d = 1.0 * wl    # for q3a
antpos = antennae_position(d)
pos_data = AOA(antpos, data, wl)
plt.figure()
plt.plot(np.real(antpos), np.imag(antpos),'rs')
plt.xlim([-10,150])
plt.ylim([-10,150])
plt.grid(1)
plt.title('Antenna Placing for 1.0*wl antenna distance')

plt.figure()
plt.plot(pos_data[15:,0],pos_data[15:,1],'.')
plt.xlim([-1,1])
plt.ylim([-1,1])
plt.grid(1)
plt.xlabel('dcosx sin(theta)cos(phi)')
plt.ylabel('dcosy sin(theta)sin(phi)')
plt.title('AOA Coverage for 1.0*wl antenna distance')

#3c
d = 1.5 * wl    # for q3a
antpos = antennae_position(d)
pos_data = AOA(antpos, data, wl)
plt.figure()
plt.plot(np.real(antpos), np.imag(antpos),'rs')
plt.xlim([-10,150])
plt.ylim([-10,150])
plt.grid(1)
plt.title('Antenna Placing for 1.5*wl antenna distance')

plt.figure()
plt.plot(pos_data[15:,0],pos_data[15:,1],'.')
plt.xlim([-1,1])
plt.ylim([-1,1])
plt.grid(1)
plt.xlabel('dcosx sin(theta)cos(phi)')
plt.ylabel('dcosy sin(theta)sin(phi)')
plt.title('AOA Coverage for 1.5*wl antenna distance')